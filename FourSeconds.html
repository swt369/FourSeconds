<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script src='QuintusLib.js'></script>

    <script>
        function clampX(p) {
            if (p.x <= p.w / 2) {
                p.x = p.w / 2 + 1;
                if (p.vx) {
                    p.vx *= -1;
                }
            } else if (p.x >= Q.width - p.w / 2) {
                p.x = Q.width - p.w / 2 - 1;
                if (p.vx) {
                    p.vx *= -1;
                }
            }
        }

        function clampY(p) {
            if (p.y <= p.h / 2) {
                fail();
            } else if (p.y >= Q.height - p.h / 2) {
                p.y = Q.height - p.h / 2 - 1;
                if (p.vy) {
                    p.vy *= -1;
                }
            }
        }

        function appendScore(delta) {
            scoreTarget += delta;
        }

        function destroyOneHeart() {
            if (lifeLeft <= 0) 
            {
                return false;
            }

            hearts[--lifeLeft].destroy();
            return true;
        }

        function resetGame() {
            Q.clearStages();
            scoreCurrent = 0;
            scoreTarget = 0;
            uiStaged = false;
            isProgressBarActive = false;
            timeLeft = 0;
            isWheelActive = false;
            lifeLeft = MAX_HEART;
            Q.stageScene(STAGE_BACKGROUND);
            Q.stageScene(STAGE_MAIN, 1);
            initializeSequence();
            curSequenceIndex = 0;
        }

        function changeBackground(bg) {
            background.asset(bg);
        }

        function stageUI() {
            if (uiStaged == false) {
                Q.stageScene(STAGE_UI, 2);
                uiStaged = true;
            }
        }

        function nextStage() {
            if (!nextStageFlag) {
                return;
            }
            nextStageFlag = false;
            changeBackground(backgrounds[0]);
            resetProgressBarTime();
            Q.stageScene(stages[stageSequence[curSequenceIndex]], 1);
            tintIn(stageInfos[stageSequence[curSequenceIndex]]);
            if (++curSequenceIndex >= stageSequence.length) {
                initializeSequence();
                curSequenceIndex = 0;
            }
            tintForResultShown = false;
        }

        function WheelAnimIn() {
            wheel.p.x = WHEEL_START_X;
            wheelFill.p.x = WHEEL_START_X;
            wheelText.p.x = WHEEL_START_X;
            wheelFill.p.angle = 0;
            nextStageFlag = true;
            changeBackground(backgrounds[0]);
            var wheelComponents = new Array(wheel, wheelFill, wheelText);
            resetWheelTime();
            for (var i = 0 ; i < wheelComponents.length ; i++){
                wheelComponents[i].animate({
                    x:          Q.width / 2,
                },
                0.8,
                Q.Easing.Linear);
            }
        }

        function WheelAnimOut() {
            var wheelComponents = new Array(wheel, wheelFill, wheelText);
            for (var i = 0 ; i < wheelComponents.length ; i++){
                wheelComponents[i].animate({
                    x:          WHEEL_END_X,
                },
                0.8,
                Q.Easing.Linear,
                {
                    callback: function() {
                        nextStage();
                    }
                });
            }
        }

        function resetProgressBarTime() {
            isProgressBarActive = true;
            timeLeft = TIME_FULL;
        }

        function resetWheelTime() {
            isWheelActive = true;
            wheelCurrentTime = TIME_FULL;
        }

        function randomBetween(min, max) {
            return min + Math.random() * (max - min);
        }

        function randomIntBetween(min, max) {
            return Math.floor(randomBetween(min, max));
        }

        function randomNextToFollow() {
            needToFollow--;
            nextToFollowIndex = Math.floor(Math.random() * keyIndexs.length);
            keySprites[nextToFollowIndex].asset(keyFulls[nextToFollowIndex]);
            for (var i = 0 ; i < keySprites.length ; i++) {
                if (i == nextToFollowIndex) {
                    continue;
                }
                keySprites[i].asset(keyEmptys[i]);
            }
        }

        function movingXY(obj, dt) {
            var vx = 100;
            var vy = 100;
            if (obj.p.vx) {
                vx = obj.p.vx;
            }
            if (obj.p.vy) {
                vy = obj.p.vy;
            }
            var distX = 0;
            var distY = 0;
            if (Q.inputs["left"]) {
                distX -= vx * dt;
            }
            if (Q.inputs["right"]) {
                distX += vx * dt;
            }
            if (Q.inputs["up"]) {
                distY -= vy * dt;
            }
            if (Q.inputs["down"]) {
                distY += vy * dt;
            }
            obj.p.x += distX;
            obj.p.y += distY;
        }

        function isSpaceDown() {
            return isKeyDown("fire");
        }

        function isKeyDown(key) {
            var curTime = new Date().getTime();
            if (curTime - lastClickTime < clickInterval) {
                return false;
            }
            if (Q.inputs[key]) {
                lastClickTime = curTime;
                return true;
            } 
            return false;
        }

        function isPointInRect(x, y, rect) {
            if (x > rect.l && x < rect.r && y > rect.t && y < rect.b) {
                return true;
            }
            return false;
        }

        function destroyAfter(obj, delay) {
            setTimeout(() => {
                obj.destroy()
            }, (delay < timeLeft ? delay : timeLeft - 0.01) * 1000);
        }

        function fakeDestroy(obj) {
            var p = obj.p;
            p.y = 1000;
            if (p.vx) {
                p.vx = 0;
            }
            if (p.vy) {
                p.vy = 0;
            }
            if (obj.stop) {
                obj.stop();
            }
        }

        function hasDefined(obj) {
            return typeof obj === "undefined" ? false : true;
        }

        function tintIn(str) {
            tintBackground.stop();
            tintText.stop();
            tintBackground.animate({
                opacity:        1,
            },
            0.5,
            Q.Easing.Linear,
            {
                callback:       function() {
                    tintBackground.animate({
                        opacity:        0,
                    },
                    0.5,
                    Q.Easing.Linear
                    );
                }
            });

            tintText.p.label = str;
            tintText.animate({
                opacity:        1,
            },
            0.5,
            Q.Easing.Linear,
            {
                callback:       function() {
                    tintText.animate({
                        opacity:        0,
                    },
                    0.5,
                    Q.Easing.Linear,
                    {
                        callback:       function() {
                            tintText.p.label = "";
                        }
                    });
                }
            });
        }

        function succeed() {
            if (!tintForResultShown) {
                tintIn(successfulTints[Math.floor(Math.random() * successfulTints.length)]);
            }
            tintForResultShown = true;
            heartFlag = true;
        }

        function fail() {
            if (!tintForResultShown) {
                tintIn(failingTints[Math.floor(Math.random() * failingTints.length)]);
            }
            tintForResultShown = true;
            heartFlag = false;
        }

        function initializeSequence(sequence) {
            stageSequence = new Array(stages.length);
            for (var i = 0 ; i < stages.length ; i++) {
                stageSequence[i] = i;
            }

            var k = stageSequence.length * 5;
            while (k--) {
                var one = randomIntBetween(0, stageSequence.length);
                var another = randomIntBetween(0, stageSequence.length);
                var temp = stageSequence[one];
                stageSequence[one] = stageSequence[another];
                stageSequence[another] = temp;
            }
        }
    </script>
</head>

<body>
    <canvas id = 'Main' width = '600' height = '480' style="border:1px solid #000"></canvas>

    <script>
        var SCORE_PER_MISSION = 100;
        var SCORE_BONUS_SMALL = 20;
        var SCORE_BONUS_MEDIUM = 50;
        var SCORE_BONUS_BIG = 120;

        var keyListener = null;
        var lastClickTime = -1;
        var clickInterval = 120;

        var STAGE_BLOCK_BREAKER = "STAGE_BLOCK_BREAKER";
        var BALL_VX_MIN = 100;
        var BALL_VX_MAX = 250;
        var BALL_VY_MIN = 100;
        var BALL_VY_MAX = 300;
        var BALL_COUNT = 3;
        var ballVXs = null;
        var ballVYs = null;

        var STAGE_ARROW_FOLLOW = "STAGE_ARROW_FOLLOW";
        var NEED_TO_FOLLOW = 6;
        var needToFollow;
        var keyIndexs = new Array("up", "right", "down", "left", "fire")
        var keyEmptys = new Array(
            "Arrow_Up_Empty.png",
            "Arrow_Right_Empty.png",
            "Arrow_Down_Empty.png",
            "Arrow_Left_Empty.png",
            "Space_Empty.png");
        var keyFulls = new Array(
            "Arrow_Up_Full.png",
            "Arrow_Right_Full.png",
            "Arrow_Down_Full.png",
            "Arrow_Left_Full.png",
            "Space_Full.png");
        var keySprites = new Array(5);
        var nextToFollowIndex;

        var STAGE_ARROW_NOT_FOLLOW = "STAGE_ARROW_NOT_FOLLOW";

        var STAGE_ROCKET_BREAKOUT = "STAGE_ROCKET_BREAKOUT";
        var ROCKET_X = 100;
        var ROCKET_START_Y = 100;
        var ROCKET_END_Y = 380; 
        var ROCKET_VX = 1500;
        var rocket = null;

        var STAGE_JUMP_ADVENTURE = "STAGE_JUMP_ADVENTURE";

        var STAGE_SHOOT_BALLOONS = "STAGE_SHOOT_BALLOONS";
        var NEED_TO_SHOOT = 4;
        var AIM_MOVING_SPEED = 100.0;
        var GENERATE_BALLOON_INTERVAL_MIN = 0.15;
        var GENERATE_BALLOON_INTERVAL_MAX = 0.2;
        var BALLOONS = new Array(
            "Balloon_Blue.png",
            "Balloon_Cyan.png",
            "Balloon_Pink.png",
            "Balloon_Yellow.png"
            );
        var shotCount;
        var BALLOON_START_Y = 700;
        var BALLOON_SPEED_Y_MIN = -100;
        var BALLOON_SPEED_Y_MAX = -600;
        var BALLOON_SCALE_MIN = 0.8;
        var BALLOON_SCALE_MAX = 1.5;

        var STAGE_GO_OVER_BRIDGE = "STAGE_GO_OVER_BRIDGE";
        var CAR_SPEED_X = 200;
        var CAR_SPEED_Y = 180;
        var WIND_FORCE = 150;
        var RIVER_RECT_1 = new Object();
        RIVER_RECT_1.l = 96;
        RIVER_RECT_1.t = 0;
        RIVER_RECT_1.r = 480;
        RIVER_RECT_1.b = 120;
        var RIVER_RECT_2 = new Object();
        RIVER_RECT_2.l = 96;
        RIVER_RECT_2.t = 320;
        RIVER_RECT_2.r = 480;
        RIVER_RECT_2.b = 480;
        var DESTINATION_RECT = new Object();
        DESTINATION_RECT.l = 480;
        DESTINATION_RECT.t = 150;
        DESTINATION_RECT.r = 600;
        DESTINATION_RECT.b = 300;

        var STAGE_FAST_CALCULATION = "STAGE_FAST_CALCULATION";
        var currentX;
        var currentY;

        var STAGE_SEARCHING_TREASURE = "STAGE_SEARCHING_TREASURE";

        var stages = new Array(
            STAGE_ARROW_FOLLOW,
            STAGE_ARROW_NOT_FOLLOW,
            STAGE_BLOCK_BREAKER,
            STAGE_JUMP_ADVENTURE,
            STAGE_ROCKET_BREAKOUT,
            STAGE_SHOOT_BALLOONS,
            STAGE_GO_OVER_BRIDGE,
            STAGE_FAST_CALCULATION,
            STAGE_SEARCHING_TREASURE,
        );
        var stageSequence = null;
        initializeSequence();
        var curSequenceIndex = 0;
        var nextStageFlag = true;
        var backgrounds = new Array("Background_White.png");
        var stageInfos = new Array(
            "Follow!",
            "Don't Touch!",
            "Defend!",
            "Avoid!",
            "Break Out!",
            "Shoot!",
            "Go Across!",
            "Choose!",
            "Open Chest!"
        );
        var successfulTints = new Array(
            ":)",
            "Fantastic!",
            "Impressing!",
            "So Good!",
            "Great!",
            "Wonderful!"
        );
        var failingTints = new Array(
            "Oops.",
            "Boo!",
            "How Sad!",
            "Awww..",
            "Emmmmm..",
            "You Awake??"
        );

        var STAGE_BACKGROUND = "STAGE_BACKGROUND";
        var background = null;

        var STAGE_UI = "UI";
        var uiStaged = false;
        var SCORE_STATIC_TEXT_X = 140;
        var SCORE_STATIC_TEXT_Y = -220;
        var SCORE_TEXT_X = 230;
        var SCORE_TEXT_Y = -220;
        var SCORE_INCREASE_SPEED = 20.0;
        var scoreText = null;
        var scoreCurrent = 0.0;
        var scoreTarget = 0.0;
        var HEART_START_X = -265;
        var HEART_START_Y = -220;
        var HEART_SIZE = 30;
        var HEART_PADDING = 3;
        var MAX_HEART = 5;
        var lifeLeft = MAX_HEART;
        var hearts = new Array(MAX_HEART);
        var heartFlag = false;
        var tintForResultShown = false;
        var PROGRESS_BAR_START_X = 0;
        var PROGRESS_BAR_START_Y = 223;
        var PROGRESS_BAR_WIDTH = 600;
        var PROGRESS_BAR_HEIGHT = 30;
        var isProgressBarActive = false;
        var TIME_FULL = 4.0;
        var timeLeft = 0;
        var tintBackground = null;
        var tintText = null

        var STAGE_MAIN = "STAGE_MAIN";
        var TITLE_X = -110;
        var TITLE_Y = -200;
        var TITLE_CONTENT = "Four Seconds";
        var TITLE_SIZE = 48;
        var TITLE_COLOR = "rgba(255, 255, 255, 1)";
        var EXTRA_X = -35;
        var EXTRA_Y = -150;
        var EXTRA_CONTENT = "How much could you do in 4 seconds?";
        var EXTRA_SIZE = 24;
        var EXTRA_COLOR = "rgba(255, 255, 255, 1)";
        var BUTTON_PLAY_X = 170;
        var BUTTON_PLAY_Y = 210;
        var WHEEL_START_X = -400;
        var WHEEL_END_X = 1000;
        var WHEEL_TEXT_OFFSET_Y = 25;
        if(navigator.userAgent.indexOf("Chrome") >= 0){
            WHEEL_TEXT_OFFSET_Y = -15;
        }
        var wheel = null;
        var wheelFill = null;
        var wheelText = null;
        var wheelManager = null;
        var isWheelActive = false;
        var wheelCurrentTime = TIME_FULL;

        var Q = Quintus()
        .include("Sprites, Scenes, Input, 2D, Touch, UI, Anim")
        .setup('Main')
        .controls()
        .touch();

        Q.Sprite.extend("Ball", {
            init: function(p) {
                this._super(p, {
                    asset:          "Ball.png",
                    type:           Q.SPRITE_ENEMY,
                    collisionMask:  Q.SPRITE_ACTIVE,
                });
                this.add('2d');
            },

            step: function(dt) {
                var p = this.p;
                clampX(p);
                clampY(p);
            }
        });

        Q.Sprite.extend("Bar", {
            init: function(p) {
                this._super(p, {
                    gravityY:       0,
                    asset:          "Bar.png",
                    speed:          600,
                    type:           Q.SPRITE_ACTIVE,
                    collisionMask:  Q.SPRITE_ENEMY,
                });
                this.add("2d, platformerControls");
                this.on("bump.left", function(collision) {
                    var p = collision.obj.p;
                    p.vx = -ballVXs[p.index];
                    p.x -= 5;
                });
                this.on("bump.right", function(collision) {
                    var p = collision.obj.p;
                    p.vx = ballVXs[p.index];
                    p.x += 5;
                });
                this.on("bump.top", function(collision) {
                    var p = collision.obj.p;
                    p.vy = -ballVYs[p.index];
                    p.y -= 5;
                });
                this.on("bump.bottom", function(collision) {
                    var p = collision.obj.p;
                    p.vy = ballVYs[p.index];
                    p.y += 5;
                });
            },

            step: function(dt) {
                clampX(this.p);
            }
        });

        Q.Sprite.extend("BalloonExplosion", {
            init: function(p) {
                this._super(p, {
                    asset:          "Balloon_Explosion.png"
                });
            }
        });

        Q.UI.ProgressBar = Q.Sprite.extend("UI.ProgressBar", {
            init: function(p) {
                this._super(Q._defaults(p||{}, {
                    type:           Q.SPRITE_UI,
                    currentValue:   0.0,
                    maxValue:       100.0
                }));
            },

            updateValue: function(value) {
                this.p.currentValue = value >= 0 ? value : 0;
                this.p.cx = (3.0 - 2 * (this.p.currentValue / this.p.maxValue)) * (PROGRESS_BAR_WIDTH / 2);
            }
        });

        Q.Sprite.extend("Background", {
            init: function(p) {
                this._super(p, {
                    x:          Q.width / 2,
                    y:          Q.height / 2,
                })
            }
        })

        Q.Sprite.extend("Wheel", {
            init: function(p) {
                this._super(p, {
                    asset:      "Wheel.png"
                });
            }
        });

        Q.Sprite.extend("WheelFill", {
            init: function(p) {
                this._super(p, {
                    asset:      "Wheel_Fill.png"
                });
            }
        });

        Q.Sprite.extend("WheelManager", {
            init: function(p) {
                this._super(p);
            },

            step: function(dt) {
                if (isWheelActive == false) {
                    return;
                }

                wheelCurrentTime -= dt;
                if (wheelCurrentTime <= 0) {
                    wheelCurrentTime = 0;
                    isWheelActive = false;
                    WheelAnimOut();
                }
                wheelFill.p.angle = (TIME_FULL - wheelCurrentTime) / TIME_FULL * 360;
                wheelText.p.label = Math.ceil(wheelCurrentTime).toString();
            }
        });

        Q.Sprite.extend("KeyListener", {
            init: function(p) {
                this._super(p);
            }
        });

        Q.Sprite.extend("SceneManager", {
            init: function(p) {
                this._super(p);
            }
        });

        Q.scene(STAGE_BLOCK_BREAKER, function(stage) {
            ballVXs = new Array(BALL_COUNT);
            ballVYs = new Array(BALL_COUNT);
            for (var i = 0 ; i < BALL_COUNT ; i++) {
                ballVXs[i] = randomBetween(BALL_VX_MIN, BALL_VX_MAX);
                ballVYs[i] = randomBetween(BALL_VY_MIN, BALL_VY_MAX);
                stage.insert(new Q.Ball({
                    x:          randomBetween(100, 500),
                    y:          randomBetween(200, 440),
                    vx:         ballVXs[i],
                    vy:         ballVYs[i],
                    index:      i,
                    gravityY:   0,
                }));
            }

            var bar = stage.insert(new Q.Bar({
                x:          300,
                y:          50,
            }));

            heartFlag = true;
        });

        Q.scene(STAGE_ARROW_FOLLOW, function(stage) {
            keySprites[0] = stage.insert(new Q.Sprite({
                x:          80,
                y:          200,
                asset:      "Arrow_Up_Empty.png"
            }));

            keySprites[1] = stage.insert(new Q.Sprite({
                x:          230,
                y:          200,
                asset:      "Arrow_Right_Empty.png"
            }));

            keySprites[2] = stage.insert(new Q.Sprite({
                x:          370,
                y:          200,
                asset:      "Arrow_Down_Empty.png"
            }));

            keySprites[3] = stage.insert(new Q.Sprite({
                x:          510,
                y:          200,
                asset:      "Arrow_Left_Empty.png"
            }));

            keySprites[4] = stage.insert(new Q.Sprite({
                x:          300,
                y:          350,
                asset:      "Space_Empty.png"
            }));

            keyListener = stage.insert(new Q.KeyListener());
            keyListener.step = function(dt) {
                if (isKeyDown(keyIndexs[nextToFollowIndex])) {
                    if (needToFollow == 0) {
                        succeed();
                    } else if (needToFollow < 0) {
                        appendScore(SCORE_BONUS_SMALL);
                    }
                    randomNextToFollow();
                }
            };

            heartFlag = false;
            needToFollow = NEED_TO_FOLLOW;
            randomNextToFollow();
        });

        Q.scene(STAGE_ARROW_NOT_FOLLOW, function(stage) {
            keySprites[0] = stage.insert(new Q.Sprite({
                x:          80,
                y:          200,
                asset:      "Arrow_Up_Full.png"
            }));

            keySprites[1] = stage.insert(new Q.Sprite({
                x:          230,
                y:          200,
                asset:      "Arrow_Right_Full.png"
            }));

            keySprites[2] = stage.insert(new Q.Sprite({
                x:          370,
                y:          200,
                asset:      "Arrow_Down_Full.png"
            }));

            keySprites[3] = stage.insert(new Q.Sprite({
                x:          510,
                y:          200,
                asset:      "Arrow_Left_Full.png"
            }));

            keySprites[4] = stage.insert(new Q.Sprite({
                x:          300,
                y:          350,
                asset:      "Space_Full.png"
            }));

            keyListener = stage.insert(new Q.KeyListener());
            keyListener.step = function(dt) {
                for (var i = 0 ; i < keyIndexs.length ; i++) {
                    if (Q.inputs[keyIndexs[i]]) {
                        fail();
                    }
                }
            };

            var forbid = stage.insert(new Q.Sprite({
                x:          300,
                y:          240,
                asset:      "Forbid.png"
            }))
            forbid.add("tween");
            forbid.animate({
                opacity:    0
            },
            1,
            {
                delay:      0
            });
            forbid.animate({
                opacity:    1
            },
            1,
            {
                delay:      1
            });
            forbid.animate({
                opacity:    0
            },
            1,
            {
                delay:      2
            });
            forbid.animate({
                opacity:    1
            },
            1,
            {
                delay:      3
            });

            heartFlag = true;
        });

        Q.scene(STAGE_ROCKET_BREAKOUT, function(stage) {
            explode = stage.insert(new Q.Sprite({
                x:          -500,
                y:          -500,
                asset:      "Explode.png",
                opacity:    0
            }));

            var up = stage.insert(new Q.Sprite({
                x:          550,
                y:          100 - 1,
                asset:      "Easy_Wall.png"
            }));
            up.on("hit", function(collision) {
                explode.p.opacity = 1;
                explode.p.x = collision.obj.p.x;
                explode.p.y = collision.obj.p.y;
                setTimeout(function() {
                    explode.destroy();
                }, 
                timeLeft > 1 ? 1000 : timeLeft * 1000 - 1);
                collision.obj.stop();
                collision.obj.destroy();
            }); 
            
            var middle = stage.insert(new Q.Sprite({
                x:          1000,
                y:          240,
                opacity:    0,
                asset:      "Easy_Wall.png"
            }));
            middle.on("hit", function(collision) {
                if (timeLeft >= 3) {
                    appendScore(SCORE_BONUS_BIG);
                } else if (timeLeft >= 2) {
                    appendScore(SCORE_BONUS_MEDIUM);
                } else if (timeLeft >= 1) {
                    appendScore(SCORE_BONUS_SMALL);
                }
                succeed();
            });

            var down = stage.insert(new Q.Sprite({
                x:          550,
                y:          380 + 1,
                asset:      "Easy_Wall.png"
            }));
            down.on("hit", function(collision) {
                explode.p.opacity = 1;
                explode.p.x = collision.obj.p.x;
                explode.p.y = collision.obj.p.y;
                setTimeout(function() {
                    explode.destroy();
                }, 
                TIME_FULL - timeLeft > 1 ? 1000 : (TIME_FULL - timeLeft) * 1000);
                collision.obj.stop();
                collision.obj.destroy();
            });

            rocket = stage.insert(new Q.Sprite({
                x:          ROCKET_X,
                y:          ROCKET_START_Y,
                gravityY:   0,
                asset:      "Rocket.png"
            }));
            rocket.add("tween, 2d");
            rocket.step = function(dt) {
                if (isSpaceDown()) {
                    this.stop();
                    this.p.vx = ROCKET_VX;
                }
            };
            rocket.animate({
                y:          ROCKET_END_Y
            },
            1,
            Q.Easing.Quadratic.InOut,
            {
                delay:      0
            });
            rocket.animate({
                y:          ROCKET_START_Y
            },
            1,
            Q.Easing.Quadratic.InOut,
            {
                delay:      1
            });
            rocket.animate({
                y:          ROCKET_END_Y
            },
            1,
            Q.Easing.Quadratic.InOut,
            {
                delay:      2
            });
            rocket.animate({
                y:          ROCKET_START_Y
            },
            1,
            Q.Easing.Quadratic.InOut,
            {
                delay:      3
            });

            heartFlag = false;
        });

        Q.scene(STAGE_JUMP_ADVENTURE, function(stage) {
            Q.sheet("Crates",
                "Crates.png",
                {
                    "sx": 0,
                    "sy": 0,
                    "cols": 2,
                    "tilew": 32,
                    "tileh": 32,
                    "frames": 2
            });

            stage.insert(new Q.Repeater({
                asset:      "Background_Wall.png",
                speedX:     0.5 
            }));

            stage.insert(new Q.Sprite({
                asset:      "Background_Floor.png",
                x:          400,
                y:          420,
            }));
            stage.insert(new Q.Sprite({
                asset:      "Background_Floor.png",
                x:          1400,
                y:          420,
            }));
            stage.insert(new Q.Sprite({
                asset:      "Background_Floor.png",
                x:          2400,
                y:          420,
            }));

            var tyre = stage.insert(new Q.Sprite({
                asset:      "Tyre.png",
                x:          200,
                y:          0,
                vx:         400,
                gravityY:   1500
            }));
            tyre.p.points = [];
            for (var i = 0 ; i < 36 ; i++) {
                tyre.p.points.push([tyre.p.w / 2 * Math.cos(i * 10 / 180 * Math.PI), tyre.p.w / 2 * Math.sin(i * 10 / 180 * Math.PI)]);
            }
            tyre.add("2d");
            tyre.step = function(dt) {
                this.p.angle += dt * 360 * 3;
                stage.viewport.centerOn(tyre.p.x + 200, Q.height / 2);
                if (tyre.p.isAlive == true && tyre.p.vy == 0 && isSpaceDown()) {
                    this.p.vy = -650;
                }
            };
            tyre.p.isAlive = true;

            for (var i = 0.5 ; i <= 3.5 ; i++) {
                setTimeout(dt => {
                    var box = stage.insert(new Q.Sprite({
                        x:          tyre.p.x + Q.width + 50,
                        y:          250,
                        vx:         -100 - 200 * Math.random(),
                        gravityY:   0,
                        sheet:      "Crates",
                        frame:      Math.random() < 0.5 ? 0 : 1,
                        scale:      1 + Math.random() * 1.5
                    }));
                    box.p.angleSpeed = 360 * (-3 + Math.random() * 6);
                    box.add("2d");
                    box.step = function(dt) {
                        this.p.angle += dt * box.p.angleSpeed; 
                    };
                    box.on("hit", function(collision) {
                        fail();
                        fakeDestroy(collision.obj);
                        this.p.vx = 500;
                        this.p.vy = -300;
                    });
                }, i * 1000);
            }

            heartFlag = true;

            stage.add("viewport");

            var manager = stage.insert(new Q.SceneManager());
        });

        Q.scene(STAGE_SHOOT_BALLOONS, function(stage) {
            shotCount = 0;
            aim = stage.insert(new Q.Sprite({
                x:              Q.width / 2,
                y:              Q.height / 2,
                vx:             600,
                vy:             600,
                asset:          "Aim.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE,
            }));
            aim.step = function(dt){
                movingXY(this, dt);
                if (isSpaceDown()) {
                    var target = Q.stage(1).locate(this.p.x, this.p.y, Q.SPRITE_ACTIVE);
                    if (target && target.p.asset.match("Balloon_")) {
                        shotCount++;
                        if (shotCount >= NEED_TO_SHOOT) {
                            appendScore(SCORE_BONUS_MEDIUM);
                            succeed();
                        } else {
                            appendScore(SCORE_BONUS_SMALL);
                        }
                        target.destroy();
                        var explosion = stage.insert(new Q.BalloonExplosion({
                            x:          this.p.x,
                            y:          this.p.y,
                        }));
                        setTimeout(() => {
                            explosion.destroy();
                        }, 50);
                    }
                }
            };

            var t = 0.0;
            while (1) {
                t += randomBetween(GENERATE_BALLOON_INTERVAL_MIN, GENERATE_BALLOON_INTERVAL_MAX);
                if (t >= TIME_FULL) {
                    break;
                }
                setTimeout(() => {
                    var balloon = stage.insert(new Q.Sprite({
                        asset:          BALLOONS[Math.floor(Math.random() * BALLOONS.length)],
                        x:              randomBetween(0, 600),
                        y:              BALLOON_START_Y,
                        vy:             randomBetween(BALLOON_SPEED_Y_MIN, BALLOON_SPEED_Y_MAX),
                        gravityY:       0,
                        scale:          randomBetween(BALLOON_SCALE_MIN, BALLOON_SCALE_MAX),
                        type:           Q.SPRITE_ACTIVE,
                        collisionMask:  Q.SPRITE_NONE
                    }));
                    balloon.add("2d");
                }, t * 1000);
            }

            heartFlag = false;
        });

        Q.scene(STAGE_GO_OVER_BRIDGE, function(stage) {
            heartFlag = false;
            changeBackground("GoOverBridge_Map.png");
            var car = stage.insert(new Q.Sprite({
                x:              50,
                y:              Q.height / 2,
                asset:          "Car.png",
                vx:             300,
                vy:             250,
                isAlive:        true,
                isDone:         false,
                type:           Q.SPRITE_ACTIVE,
                collisionMask:  Q.SPRITE_ENEMY
            }));
            car.step = function(dt) {
                if (this.p.isDone == true) {
                    this.p.x += this.p.vx * dt;
                    return;
                }
                if (this.p.isAlive == false) {
                    return;
                }
                movingXY(this, dt);
                if (isPointInRect(this.p.x, this.p.y, DESTINATION_RECT)) {
                    this.p.isDone = true;
                    succeed();
                    return;
                }
                if (isPointInRect(this.p.x, this.p.y, RIVER_RECT_1) || isPointInRect(this.p.x, this.p.y, RIVER_RECT_2)) {
                    var spray = stage.insert(new Q.Sprite({
                        x:          this.p.x,
                        y:          this.p.y,
                        asset:      "Spray.png",
                    }));
                    destroyAfter(spray, 1);
                    this.p.isAlive = false;
                    this.p.y = 1000;
                }
            };
            var windAngle = randomBetween(0, 360);
            var wind = stage.insert(new Q.Sprite({
                x:              50,
                y:              Q.height / 2,
                asset:          "Easy_Wind.png",
                vx:             WIND_FORCE * Math.cos(windAngle / 180 * Math.PI),
                vy:             WIND_FORCE * Math.sin(windAngle / 180 * Math.PI),
                gravityY:       0,
                angle:          windAngle,
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));
            wind.step = function(dt) {
                if (car.p.isDone == true || car.p.isAlive == false) {
                    return;
                }
                car.p.x += wind.p.vx * dt;
                car.p.y += wind.p.vy * dt;
            };
            wind.add("2d");

            for (var i = 0 ; i < 3 ; i++) {
                setTimeout(() => {
                    var enemy = stage.insert(new Q.Sprite({
                        x:              600,
                        y:              randomBetween(180, 320),
                        asset:          "Car_Enemy.png",
                        type:           Q.SPRITE_ENEMY,
                        collisionMask:  Q.SPRITE_ACTIVE,
                        vx:             -randomBetween(200, 400),
                        vy:             0,
                        gravityY:       0
                    }));
                    enemy.add("2d");
                    enemy.on("hit", function(collision) {
                        var p = collision.obj.p;
                        if (p.asset != "Car.png") {
                            return;
                        }
                        var explosion = stage.insert(new Q.Sprite({
                            x:              (p.x + this.p.x) / 2,
                            y:              (p.y + this.p.y) / 2,
                            asset:          "Balloon_Explosion.png",
                            type:           Q.SPRITE_NONE,
                            collisionMask:  Q.SPRITE_NONE
                        }));
                        destroyAfter(explosion, 1);
                        enemy.destroy();
                        if (p.isDone == false) {
                            fakeDestroy(collision.obj);
                        }
                    })
                }, randomBetween(i, i + 1) * 1000);
            }
        });

        Q.scene(STAGE_FAST_CALCULATION, function(stage) {
            currentX = 0;
            currentY = 0;
            heartFlag = false;
            for (var i = 0 ; i < 3 ; i++) {
                for (var j = 0 ; j < 3 ; j++) {
                    stage.insert(new Q.Sprite({
                        x:              30 + j * 60,
                        y:              160 + i * 80,
                        asset:          (i * 3 + j + 1).toString() + ".png",
                        type:           Q.SPRITE_NONE,
                        collisionMask:  Q.SPRITE_NONE 
                    }));
                }
            }
            stage.insert(new Q.Sprite({
                x:          90,
                y:          400,
                asset:      "0.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));

            var selected = stage.insert(new Q.Sprite({
                x:              30,
                y:              160,
                asset:          "Selected.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE,
                hasSelected:    false
            }));
            selected.step = function(dt) {
                if (this.p.hasSelected) {
                    return;
                }

                var changed = false;

                if (isKeyDown("up")) {
                    currentY = currentY == 0 ? 3 : currentY - 1;
                    changed = true;
                } else if (isKeyDown("down")) {
                    currentY = (currentY + 1) % 4;
                    changed = true;
                }

                if (currentY == 3) {
                    if (currentX != 1) {
                        currentX = 1;
                        changed = true;
                    }
                } else {
                    if (isKeyDown("left")) {
                        currentX = currentX == 0 ? 2 : currentX - 1;
                        changed = true;
                    } else if (isKeyDown("right")) {
                        currentX = (currentX + 1) % 3;
                        changed = true;
                    }
                }

                if (changed) {
                    this.p.x = 30 + currentX * 60;
                    this.p.y = 160 + currentY * 80;
                    if (hasDefined(answerSprite)) {
                        if (currentY == 3) {
                            answerSprite.asset("0.png");
                        } else {
                            answerSprite.asset((1 + currentX + currentY * 3).toString() + ".png")
                        }
                    }
                }

                if (hasDefined(answerIndex) && hasDefined(nums) && hasDefined(answerSprite) && isSpaceDown()) {
                    this.p.hasSelected = true;
                    var resultMark = stage.insert(new Q.Sprite({
                        x:              800,
                        y:              0,
                        type:           Q.SPRITE_NONE,
                        collisionMask:  Q.SPRITE_NONE,
                        asset:          "Cross.png"
                    }));
                    if (operatorUsed == "Modulo.png") {
                        nums[answerIndex] = parseInt(answerSprite.p.asset.charAt(0));
                        var left = nums[0] * 10 + nums[1];
                        var right = nums[2] * 10 + nums[3];
                        var res = nums[4] * 10 + nums[5];
                        if (left % right == res) {
                            succeed();
                            resultMark.asset("Tick.png");
                        } 
                    } else {
                        if (answerSprite.p.asset.charAt(0) == nums[answerIndex].toString()) {
                            succeed();
                            resultMark.asset("Tick.png");
                        }
                    }
                    resultMark.add("tween");
                    resultMark.animate({
                        x:              400,
                        y:              Q.height / 2,
                        angle:          -1080
                    },
                    1,
                    Q.Easing.Quadratic.Out);
                }
            };

            var expr = new Array(3);
            var operatorUsed = null;
            switch(Math.floor(randomBetween(0, 4))) {
                case 0: {
                    expr[0] = Math.floor(randomBetween(0, 99));
                    expr[1] = Math.floor(randomBetween(0, 100 - expr[0]));
                    expr[2] = expr[0] + expr[1];
                    operatorUsed = "Plus.png";
                    break;
                }
                case 1: {
                    expr[0] = Math.floor(randomBetween(0, 99));
                    expr[1] = Math.floor(randomBetween(0, expr[0]));
                    expr[2] = expr[0] - expr[1];
                    operatorUsed = "Minus.png";
                    break;
                }
                case 2: {
                    expr[0] = Math.floor(randomBetween(1, 10));
                    expr[1] = Math.floor(randomBetween(1, Math.floor(100 / expr[0])));
                    expr[2] = expr[0] * expr[1];
                    operatorUsed = "Multiply.png";
                    break;
                }
                case 3: {
                    expr[0] = Math.floor(randomBetween(1, 100));
                    expr[1] = Math.floor(randomBetween(1, expr[0]));
                    expr[2] = expr[0] % expr[1];
                    operatorUsed = "Modulo.png";
                    break;
                }
            }
            var nums = new Array(6);
            nums[0] = Math.floor(expr[0] / 10);
            nums[1] = expr[0] % 10;
            nums[2] = Math.floor(expr[1] / 10);
            nums[3] = expr[1] % 10;
            nums[4] = Math.floor(expr[2] / 10);
            nums[5] = expr[2] % 10;
            var answerIndex = Math.floor(randomBetween(0, 6));
            var answerSprite = null;
            for (var i = 0 ; i < 6 ; i++) {
                stage.insert(new Q.Sprite({
                    x:              220 + 50 * (i + (Math.floor(i / 2))),
                    y:              Q.height / 2,
                    asset:          i != answerIndex ? nums[i].toString() + ".png" : "Selected.png",
                    type:           Q.SPRITE_NONE,
                    collisionMask:  Q.SPRITE_NONE
                }));
                if (i == answerIndex) {
                    answerSprite = stage.insert(new Q.Sprite({
                    x:              220 + 50 * (i + (Math.floor(i / 2))),
                    y:              Q.height / 2,
                    asset:          "1.png",
                    type:           Q.SPRITE_NONE,
                    collisionMask:  Q.SPRITE_NONE
                    }));
                }
            }
            stage.insert(new Q.Sprite({
                x:              220 + 50 * 2,
                y:              Q.height / 2,
                asset:          operatorUsed,
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));
            stage.insert(new Q.Sprite({
                x:              220 + 50 * 5,
                y:              Q.height / 2,
                asset:          "Equal.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));
        })

        Q.scene(STAGE_SEARCHING_TREASURE, function(stage) {
            heartFlag = false;
            changeBackground("Island_Map.png");
            // stage.insert(new Q.Sprite({
            //     x:              480,
            //     y:              300,
            //     asset:          "Coconut_Tree.png",
            //     type:           Q.SPRITE_NONE,
            //     collisionMask:  Q.SPRITE_NONE
            // }));
            stage.insert(new Q.Sprite({
                x:              80,
                y:              80,
                asset:          "Sailing_Boat.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));
            var player = stage.insert(new Q.Sprite({
                x:              120,
                y:              120,
                asset:          "Easy_Player.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE,
                vx:             100,
                vy:             100
            }));
            player.step = function(dt) {
                movingXY(this, dt);
            }

            var treasure = stage.insert(new Q.Sprite({
                x:              randomBetween(200, 550),
                y:              randomBetween(200, 440),
                asset:          "Treasure_Box_Close.png",
                type:           Q.SPRITE_NONE,
                collisionMask:  Q.SPRITE_NONE
            }));
            var rectTreasure = new Object();
            rectTreasure.l = treasure.p.x - treasure.p.w / 2 - 30;
            rectTreasure.r = treasure.p.x + treasure.p.w / 2 + 30;
            rectTreasure.t = treasure.p.y - treasure.p.h / 2 - 30;
            rectTreasure.b = treasure.p.y + treasure.p.h / 2 + 30;
            treasure.step = function (dt) {
                if (!heartFlag && isSpaceDown() && isPointInRect(player.p.x, player.p.y, rectTreasure)) {
                    succeed();
                    treasure.asset("Treasure_Box_Open.png");
                }
            }
        })

        Q.scene(STAGE_UI, function(stage) {
            changeBackground(backgrounds[0]);
            var box = stage.insert(new Q.UI.Container({
                x:          Q.width / 2,
                y:          Q.height / 2,
            }));

            box.insert(new Q.UI.Text({
                x:          SCORE_STATIC_TEXT_X,
                y:          SCORE_STATIC_TEXT_Y,
                label:      "Score: "
            }));

            scoreText = box.insert(new Q.UI.Text({
                x:          SCORE_TEXT_X,
                y:          SCORE_TEXT_Y,
                label:      "0"
            }));
            scoreText.step = function(dt) {
                if (scoreCurrent < scoreTarget) {
                    delta = scoreTarget - scoreCurrent;
                    toBeIncreased = delta <= 1 ? delta : delta * dt * 0.85;
                    scoreCurrent += toBeIncreased;
                    if (scoreCurrent > scoreTarget) {
                        scoreCurrent = scoreTarget;
                    }
                    this.p.label = Math.floor(scoreCurrent).toString();
                }
            };

            // var button1 = box.insert(new Q.UI.Button({
            //     x:          -100,
            //     y:          0,
            //     fill:       "#CCCCCC",
            //     label:      "Add Score"
            // }));
            // button1.on("click", function() {
            //     appendScore(Math.random() * 100);
            // });


            // var button2 = box.insert(new Q.UI.Button({
            //     x:          100,
            //     y:          0,
            //     fill:       "#CCCCCC",
            //     label:      "Decrease Life"
            // }));
            // button2.on("click", function() {
            //     destroyOneHeart();
            // });
            for (var i = 0 ; i < MAX_HEART ; i++) {
                hearts[i] = box.insert(new Q.UI.Button({
                    x:          HEART_START_X + (HEART_SIZE + HEART_PADDING) * i,
                    y:          HEART_START_Y,
                    asset:      "Heart_Full.png",
                }));
            }

            progressBar_Full = box.insert(new Q.UI.ProgressBar({
                x:          PROGRESS_BAR_START_X,
                y:          PROGRESS_BAR_START_Y,
                asset:      "ProgressBar_Full.png",
            }));
            progressBar_Full.step = function(dt) {
                if (isProgressBarActive == false) {
                    return;
                }

                timeLeft -= dt;
                if (timeLeft <= 0) {
                    if (heartFlag == true) {
                        appendScore(SCORE_PER_MISSION);
                    } else {
                        if (destroyOneHeart() == false) {
                            resetGame();
                            return;
                        }
                    }
                    isProgressBarActive = false;
                    Q.clearStage(1);
                    if (!tintForResultShown) {
                        if (heartFlag) {
                            succeed();
                        } else {
                            fail();
                        }
                    }
                    WheelAnimIn();
                }
                this.updateValue(timeLeft / TIME_FULL * 100);
            };

            progressBar_Full.updateValue(0);

            wheel = stage.insert(new Q.Wheel({
                x:          WHEEL_START_X,
                y:          Q.height / 2,
            }));
            wheel.add("tween");

            wheelFill = stage.insert(new Q.WheelFill({
                x:          WHEEL_START_X,
                y:          Q.height / 2,
                angle:      0,
            }));
            wheelFill.add("tween");

            wheelText = stage.insert(new Q.UI.Text({
                x:          WHEEL_START_X,
                y:          Q.height / 2 + WHEEL_TEXT_OFFSET_Y,
                label:      TIME_FULL.toString(),
                size:       180,
            }));
            wheelText.add("tween");

            wheelManager = stage.insert(new Q.WheelManager());

            var helpText = stage.insert(new Q.UI.Text({
                x:              Q.width / 2,
                y:              Q.height + 100,
                label:          "Each mini game lasts 4 seconds.",
                size:           24,
            }));
            helpText.add("tween");
            helpText.animate({
                y:              Q.height / 2 + 20,
            },
            0.5,
            Q.Easing.Quadratic.Out,
            {
                callback:   function() {
                    helpText.animate({
                        y:              Q.height / 2 - 20,
                    },
                    1,
                    Q.Easing.Linear,
                    {
                        callback:   function() {
                            helpText.animate({
                                y:      -100,
                            },
                            0.5,
                            Q.Easing.Quadratic.Out,
                            {
                                callback:       function() {
                                    helpText.p.y = Q.height + 100;
                                    helpText.p.label = "Use your arrow keys and space";
                                    helpText.animate({
                                        y:          Q.height / 2 + 20,
                                    },
                                    1,
                                    Q.Easing.Quadratic.Out,
                                    {
                                        callback:   function() {
                                            helpText.animate({
                                                y:          Q.height / 2 - 20,
                                            },
                                            1,
                                            Q.Easing.Linear,
                                            {
                                                callback:       function() {
                                                    helpText.animate({
                                                        y:      -100
                                                    },
                                                    0.5,
                                                    Q.Easing.Quadratic.Out,
                                                    {
                                                        callback:       function() {
                                                            WheelAnimIn();
                                                        }
                                                    })
                                                }
                                            })
                                        }
                                    })
                                }
                            })
                        }
                    })
                }
            });

            tintBackground = stage.insert(new Q.Sprite({
                x:          Q.width / 2,
                y:          Q.height / 2 - 120,
                asset:      "Tint_Background.png",
                opacity:    0,
            }));
            tintBackground.add("tween");

            tintText = stage.insert(new Q.UI.Text({
                x:          Q.width / 2,
                y:          Q.height / 2 - 120,
                label:      "?",
                color:      "#ff0000",
                size:       84,
                opacity:    0,
            }));
            tintText.add("tween");
        });

        Q.scene(STAGE_MAIN, function(stage) {
            var box = stage.insert(new Q.UI.Container({
                x:          Q.width / 2,
                y:          Q.height / 2,
            }));

            box.insert(new Q.UI.Text({
                x:          TITLE_X,
                y:          TITLE_Y,
                label:      TITLE_CONTENT,
                size:       TITLE_SIZE,
                color:      TITLE_COLOR
            }));

            box.insert(new Q.UI.Text({
                x:          EXTRA_X,
                y:          EXTRA_Y,
                label:      EXTRA_CONTENT,
                size:       EXTRA_SIZE,
                color:      EXTRA_COLOR
            }));

            var buttonPlay = box.insert(new Q.UI.Button({
                x:          BUTTON_PLAY_X,
                y:          BUTTON_PLAY_Y,
                asset:      "Button_Play.png",
                label:      "Play"
            }));
            buttonPlay.on("click", function() {
                stageUI();
                Q.clearStage(1);
            });
        });

        Q.scene(STAGE_BACKGROUND, function(stage) {
            background = stage.insert(new Q.Background({
                asset:      "Background_Main.jpg"
            }));
        });

        Q.load("\
            Bar.png,\
            Ball.png,\
            Heart_Full.png,\
            ProgressBar_Full.png,\
            Background_Main.jpg,\
            Button_Play.png,\
            Background_White.png,\
            Wheel.png,\
            Wheel_Fill.png,\
            Arrow_Right_Empty.png,\
            Arrow_Down_Empty.png,\
            Arrow_Left_Empty.png,\
            Arrow_Up_Empty.png,\
            Arrow_Right_Full.png,\
            Arrow_Down_Full.png,\
            Arrow_Left_Full.png,\
            Arrow_Up_Full.png,\
            Space_Empty.png,\
            Space_Full.png,\
            Forbid.png,\
            Rocket.png,\
            Easy_Wall.png,\
            Explode.png,\
            Background_Wall.png,\
            Background_Floor.png,\
            Crates.png,\
            Tyre.png,\
            Balloon_Blue.png,\
            Balloon_Cyan.png,\
            Balloon_Pink.png,\
            Balloon_Yellow.png,\
            Aim.png,\
            Balloon_Explosion.png,\
            GoOverBridge_Map.png,\
            Car.png,\
            Easy_Wind.png,\
            Spray.png,\
            Car_Enemy.png,\
            0.png,\
            1.png,\
            2.png,\
            3.png,\
            4.png,\
            5.png,\
            6.png,\
            7.png,\
            8.png,\
            9.png,\
            Plus.png,\
            Minus.png,\
            Multiply.png,\
            Modulo.png,\
            Selected.png,\
            Equal.png,\
            Undetermined.png,\
            Tick.png,\
            Cross.png,\
            Island_Map.png,\
            Sailing_Boat.png,\
            Treasure_Box_Close.png,\
            Coconut_Tree.png,\
            Treasure_Box_Open.png,\
            Easy_Player.png,\
            Tint_Background.png", function() {
                Q.stageScene(STAGE_BACKGROUND);
                Q.stageScene(STAGE_MAIN, 1);
                //Q.debug = true;
                //Q.debugFill = true;
        });
    </script>
</body>
</html>
